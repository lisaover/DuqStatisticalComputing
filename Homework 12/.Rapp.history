#Set A to a value slightly greater than 0.5 because the highest y value in this piecewise function is 0.5.#
A = 0.5000001#
real.s = NULL#
N = 25000#
#
for(i in 1:N) {#
	#Draw a uniform independent random variable and transform it to be within the domain of the given density#
	x = runif(1) * 4 + 2#
	#Determine what part of the piecewise function to use based on the value of x and set the numerator equal to the appropriate function and the denominator equal to A times the uniform density that corresponds to the appropriate function - 1 for 2 <= x <= 3 and 3 for 3 <= x <= 6.#
	if (x <= 3) {#
		num = (x - 2)/2#
		denom = A*1#
		}#
	else {#
		num = (2 - (x/3))/2#
		denom = A*3#
		}#
	#Calculate the probability that the previously generated uniform is from the distribution#
	prob <- num/denom#
	#Generate a uniform independent random variable to use as a probability#
	#If the probability that the transformed x uniform could be from the given distribution is greater than the probability represented by this new uniform random variable, select the x transformed uniform and store in real.s#
	if(runif(1) < prob) {#
		real.s <- c(real.s,x)#
	}#
}#
hist(real.s)
#Set A to a value slightly greater than 0.5 because the highest y value in this piecewise function is 0.5.#
A = 0.5000001#
real.s = NULL#
N = 25000#
#
for(i in 1:N) {#
	#Draw a uniform independent random variable and transform it to be within the domain of the given density#
	x = runif(1) * 4 + 2#
	#Determine what part of the piecewise function to use based on the value of x and set the numerator equal to the appropriate function and the denominator equal to A times the uniform density that corresponds to the appropriate function - 1 for 2 <= x <= 3 and 3 for 3 <= x <= 6.#
	if (x < 3) {#
		num = (x - 2)/2#
		denom = A*1#
		}#
	else {#
		num = (2 - (x/3))/2#
		denom = A*3#
		}#
	#Calculate the probability that the previously generated uniform is from the distribution#
	prob <- num/denom#
	#Generate a uniform independent random variable to use as a probability#
	#If the probability that the transformed x uniform could be from the given distribution is greater than the probability represented by this new uniform random variable, select the x transformed uniform and store in real.s#
	if(runif(1) < prob) {#
		real.s <- c(real.s,x)#
	}#
}#
hist(real.s)
#Set A to a value slightly greater than 0.5 because the highest y value in this piecewise function is 0.5.#
A = 0.5000001#
real.s = NULL#
N = 25000#
#
for(i in 1:N) {#
	#Draw a uniform independent random variable and transform it to be within the domain of the given density#
	x = runif(1) * 4 + 2#
	#Determine what part of the piecewise function to use based on the value of x and set the numerator equal to the appropriate function and the denominator equal to A times the uniform density that corresponds to the appropriate function - 1 for 2 <= x <= 3 and 3 for 3 <= x <= 6.#
	if (x <= 3) {#
		num = (x - 2)/2#
		denom = A*1#
		}#
	else {#
		num = (2 - (x/3))/2#
		denom = A*3#
		}#
	#Calculate the probability that the previously generated uniform is from the distribution#
	prob <- num/denom#
	#Generate a uniform independent random variable to use as a probability#
	#If the probability that the transformed x uniform could be from the given distribution is greater than the probability represented by this new uniform random variable, select the x transformed uniform and store in real.s#
	if(runif(1) < prob) {#
		real.s <- c(real.s,x)#
	}#
}#
hist(real.s)
#Set A to a value slightly greater than 0.5 because the highest y value in this piecewise function is 0.5.#
A = 0.5#
real.s = NULL#
N = 25000#
#
for(i in 1:N) {#
	#Draw a uniform independent random variable and transform it to be within the domain of the given density#
	x = runif(1) * 4 + 2#
	#Determine what part of the piecewise function to use based on the value of x and set the numerator equal to the appropriate function and the denominator equal to A times the uniform density that corresponds to the appropriate function - 1 for 2 <= x <= 3 and 3 for 3 <= x <= 6.#
	if (x <= 3) {#
		num = (x - 2)/2#
		denom = A*0.25#
		}#
	else {#
		num = (2 - (x/3))/2#
		denom = A*0.25#
		}#
	#Calculate the probability that the previously generated uniform is from the distribution#
	prob <- num/denom#
	#Generate a uniform independent random variable to use as a probability#
	#If the probability that the transformed x uniform could be from the given distribution is greater than the probability represented by this new uniform random variable, select the x transformed uniform and store in real.s#
	if(runif(1) < prob) {#
		real.s <- c(real.s,x)#
	}#
}#
hist(real.s)
#Set A to a value slightly greater than 0.5 because the highest y value in this piecewise function is 0.5.#
A = 2#
real.s = NULL#
N = 25000#
#
for(i in 1:N) {#
	#Draw a uniform independent random variable and transform it to be within the domain of the given density#
	x = runif(1) * 4 + 2#
	#Determine what part of the piecewise function to use based on the value of x and set the numerator equal to the appropriate function and the denominator equal to A times the uniform density that corresponds to the appropriate function - 1 for 2 <= x <= 3 and 3 for 3 <= x <= 6.#
	if (x <= 3) {#
		num = (x - 2)/2#
		denom = A*0.25#
		}#
	else {#
		num = (2 - (x/3))/2#
		denom = A*0.25#
		}#
	#Calculate the probability that the previously generated uniform is from the distribution#
	prob <- num/denom#
	#Generate a uniform independent random variable to use as a probability#
	#If the probability that the transformed x uniform could be from the given distribution is greater than the probability represented by this new uniform random variable, select the x transformed uniform and store in real.s#
	if(runif(1) < prob) {#
		real.s <- c(real.s,x)#
	}#
}#
hist(real.s)
#The proposal density is uniform over a 4 unit interval so the height of the proposal desnity is 0.25. The maximum height of the target density is 0.5 so multiply 0.25 by 2 (A=2) to raise the proposal density above the target density. #
A = 2#
real.s = NULL#
N = 25000#
#
for(i in 1:N) {#
	#Draw a uniform independent random variable and transform it to be within the domain of the given density, 2 <= x <= 6.#
	x = runif(1) * 4 + 2#
	#Determine what part of the piecewise function to use based on the value of x and set the numerator equal to the appropriate function and the denominator equal to A times the height of the uniform density over the four unit interval.#
	if (x <= 3) {#
		num = (x - 2)/2#
		denom = A*0.25#
		}#
	else {#
		num = (2 - (x/3))/2#
		denom = A*0.25#
		}#
	#Calculate the probability that the previously generated uniform is from the target density#
	prob <- num/denom#
	#Generate a uniform independent random variable to use as a comparison probability: if the probability, prob, that the transformed x uniform could be from the given distribution is greater than the probability represented by this newly generated uniform random variable, select the x transformed uniform and store in real.s#
	if(runif(1) < prob) {#
		real.s <- c(real.s,x)#
	}#
}#
hist(real.s)#
mean(real.s)
data = read.csv(file.choose(), header=TRUE)
attach(data)
data
y = data$IgG#
x = data$Max.O2.Uptake#
x2 = x^2#
output = summary(glm(y ~ x + x2))#
N = 25000#
lag = 75#
burnin = 0#
b0 = output$coef[1,1]#
b1 = output$coef[2,1]#
b2 = output$coef[3,1]#
##
gibbs <- function(x,x2,y,b0,b1,b2,N,lag,burnin) {#
	#obtain length of data#
	n = length(x)#
	#Set N to be N*lag+burnin#
	N <- N*lag + burnin#
	#Initialize vectors to hold the beta coefficients and sigsq realizations#
	b0s = NULL#
	b1s = NULL#
	b2s = NULL#
	s2s = NULL#
	for(i in 1:N) {#
		#Generate a sigsq, s2, based on current regression coefficients b0, b1, b2#
		s2 = 1/rgamma(1, n/2, sum((y-b0-b1*x-b2*x2)^2)/2)#
		b0 = rnorm(1, sum(y-b1*x-b2*x2)/n, sqrt(s2/n))#
		b1 = rnorm(1, sum(x*(y-b0-b2*x2))/sum(x^2), sqrt(s2/sum(x^2)))#
		b2 = rnorm(1, sum(x*(y-b0-b1*x))/sum(x2^2), sqrt(s2/sum(x2^2)))#
		#if i is greater than burnin and if i is a multiple of the lag, store alpha, beta, and siqsq#
    if(i > burnin) {#
  	  if(i %% lag == 0) {#
		b0s <- c(b0s,b0)#
		b1s <- c(b1s,b1)#
		b2s <- c(b2s,b2)#
		s2s <- c(s2s,s2)#
      }#
     }	#
	}#
	vectors <- list("beta0s" = b0s, "beta1s" = b1s, "beta2s" = b2s, "sigsqs" = s2s)#
    	return(vectors)#
}#
v = gibbs(x,x2,y,b0,b1,b2,N,lag,burnin)
beta0s = v$beta0s#
beta1s = v$beta1s#
beta2s = v$beta2s#
sigsqs = v$sigsqs#
mean(beta0s)#
#[1] -100.4425#
mean(beta1s)#
#[1] 32.74851#
mean(beta2s)#
#[1] -1.288789e-06#
mean(sigsqs)#
#[1] 18087.22
par(mfrow=c(3,1)) #split plotting window into 3 rows and 1 column#
ts.plot(beta0s,xlab="Iterations") #
hist(beta0s,probability=T, cex.lab=1.5, cex.axis=1.5)#
acf(beta0s,lag.max=500)
par(mfrow=c(3,1)) #split plotting window into 3 rows and 1 column#
ts.plot(beta1s,xlab="Iterations") #
hist(beta1s,probability=T, cex.lab=1.5, cex.axis=1.5)#
acf(beta1s,lag.max=500)
par(mfrow=c(3,1)) #split plotting window into 3 rows and 1 column#
ts.plot(beta2s,xlab="Iterations") #
hist(beta2s,probability=T, cex.lab=1.5, cex.axis=1.5)#
acf(beta2s,lag.max=500)
par(mfrow=c(3,1)) #split plotting window into 3 rows and 1 column#
ts.plot(sigsqs,xlab="Iterations") #
hist(sigsqs,probability=T, cex.lab=1.5, cex.axis=1.5)#
acf(sigsqs,lag.max=500)
k=1#
mcoef <- matrix(, nrow = N, ncol = 3)#
for(i in 1:N) {  #
   		pair = c(beta0s[i], beta1s[i], beta2s[i])#
  		mcoef[k ,] = pair#
  		k = k + 1#
 }#
yhats <- matrix(, nrow = N, ncol = length(x))#
for(i in 1:N) { #
	lines <- mcoef[i,1] + mcoef[i,2]*x + mcoef[i,3]#
	yhats[i ,] = lines#
}#
#Calculate the means and the quantiles (0.975 and 0.025) of the columns (2) of the yhats matrix#
means = apply(yhats, 2, mean)
rLines = sample(1:25000, 3, replace=F)#
#Create a 3 row matrix of yhat values for each x using the randomly selected coordinates#
yhats3 <- matrix(, nrow = 3, ncol = length(x))#
for(i in 1:3) { #
	lines <- mcoef[rLines[i],1] + mcoef[rLines[i],2]*x + mcoef[rLines[i],3]*x2#
	yhats3[i ,] = lines#
}
plot(x,y)#
lines(x,yhats3[1,], lty=2)#
lines(x,yhats3[2,], lty=2)#
lines(x,yhats3[3,], lty=2)#
lines(x, means, lwd=2.5)
plot(x,y)#
lines(x,yhats3[1,], lty=2)#
lines(x,yhats3[2,], lty=2)#
lines(x,yhats3[3,], lty=2)#
lines(x, means, lwd=2.5)
plot(x, fitted(lm(y~x+x2)), type="l")
plot(x,y)#
abline(x,yhats3[1,], lty=2)
plot(x,y)#
ablines(x,yhats3[1,], lty=2)
k=1#
mcoef <- matrix(, nrow = N, ncol = 3)#
for(i in 1:N) {  #
   		coord = c(beta0s[i], beta1s[i], beta2s[i])#
  		mcoef[k ,] = coord#
  		k = k + 1#
 }
mcoef
plot(x,y)#
lines(x, yhats3[1,], lty=2)#
lines(x, yhats3[2,], lty=2)#
lines(x, yhats3[3,], lty=2)#
lines(x, means, lwd=2.5)
plot(x,y)#
lines(x, yhats3[1,], lty=2)
plot(x,y)
lines(x, yhats3[2,], lty=2)
